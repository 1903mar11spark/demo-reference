DROP TABLE BEAR;
DROP TABLE BEAR_TYPE;
DROP TABLE CAVE;
DROP TABLE BEEHIVE;
DROP TABLE BEAR_BEEHIVE;
--SCRIPTS OFTEN BEGIN WITH DROP STATEMENTS TO ENSURE NO NAMING CLASHES

--TABLE CREATION WITH PRIMARY KEYS

CREATE TABLE BEAR (
    BEAR_ID INTEGER PRIMARY KEY, --ADDING PK TO THIS COLUMN
    BEAR_NAME VARCHAR2(100),
    BIRTHDATE DATE,
    WEIGHT NUMBER(6,2) DEFAULT 200.00,
    BEAR_TYPE_ID INTEGER NOT NULL, --THIS WILL BE A NON-NULLABLE FOREIGN KEY
    CAVE_ID INTEGER --THIS WILL BE A NULLABLE FOREIGN KEY
);
/
CREATE TABLE BEAR_TYPE (
    BEAR_TYPE_ID INTEGER PRIMARY KEY,
    BEAR_TYPE_NAME VARCHAR2(100)
);
/
CREATE TABLE CAVE (
    CAVE_ID INTEGER PRIMARY KEY,
    CAVE_NAME VARCHAR2(100),
    MAX_BEARS INTEGER DEFAULT 4
);
/
CREATE TABLE BEEHIVE (
    BEEHIVE_ID INTEGER PRIMARY KEY,
    LBS_HONEY NUMBER(5,2) DEFAULT 75.00
);
/
CREATE TABLE BEAR_BEEHIVE (
    BEAR_ID INTEGER,
    BEEHIVE_ID INTEGER,
    PRIMARY KEY (BEAR_ID, BEEHIVE_ID)
);
/

--FOREIGN KEY CONSTRAINTS

--CONSTRAINT: RULE PLACED ON THE CONTENTS OF A TABLE, LIMITS WHAT MAY BE INSERTED
--TYPES - PK, FK, UNIQUE, CHECK, NOT NULL

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);
/

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE(CAVE_ID);
/

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEAR_BEEHIVE
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);
/

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEEHIVE_BEAR_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/

--ADD SOME DATA
--TWO DIFFERENT FORMATS FOR INSERTING DATA: 
--FILL ALL COLUMNS OR ONLY A SELECT FEW. 

INSERT INTO CAVE VALUES (27, 'Tampa', 8);
INSERT INTO CAVE (CAVE_ID, CAVE_NAME) VALUES (53, 'Grand Rapids');

UPDATE CAVE SET CAVE_NAME = 'Tampa' WHERE CAVE_NAME = 'Denver';

INSERT ALL
INTO BEAR_TYPE
VALUES (34, 'Grizzly')
INTO BEAR_TYPE
VALUES (35, 'Sun')
SELECT * FROM DUAL; -- DUAL IS A DUMMY TABLE 

INSERT ALL
INTO BEAR
VALUES (1, 'Barry', TO_DATE('1993-10-08', 'yyyy-mm-dd'), 350.00, 34, 53)
INTO BEAR (BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (2, 'Berneice', TO_DATE('1993-10-08', 'yyyy-mm-dd'), 34, 53)
INTO BEAR (BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (3, 'Ben', TO_DATE('1980-04-28', 'yyyy-mm-dd'), 35, 27)
SELECT * FROM DUAL;

--CREATE SEQUENCES AND TRIGGERS TO GENERATE PRIMARY KEYS

CREATE SEQUENCE SQ_BEAR_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_CAVE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEEHIVE_PK
START WITH 1000
INCREMENT BY 1;
/

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/

INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES ('Betty', TO_DATE('1999-04-04', 'yyyy-mm-dd'), 35, 27);
/
-- SOME EXAMPLES WITH JOINS, ETC.

--ADD A CAVELESS BEAR
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID)
VALUES ('Bruce', TO_DATE('1989-06-04', 'yyyy-mm-dd'), 35);
/

--ADD AN EMPTY CAVE
INSERT INTO CAVE(CAVE_NAME)
VALUES ('Philadelphia');
/

SELECT * FROM BEAR;

--SHOW CAVE DETAILS FOR EACH BEAR
SELECT B.BEAR_ID, B.BEAR_NAME, CAVE.CAVE_ID, CAVE.CAVE_NAME
FROM BEAR B --ALIAS BEAR TABLE
LEFT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;

SELECT B.BEAR_ID, B.BEAR_NAME, CAVE.CAVE_ID, CAVE.CAVE_NAME
FROM BEAR B --ALIAS BEAR TABLE
RIGHT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID; --NO BRUCE, YES PHILLY

SELECT B.BEAR_ID, B.BEAR_NAME, CAVE.CAVE_ID, CAVE.CAVE_NAME
FROM BEAR B --ALIAS BEAR TABLE
FULL JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;

--DISPLAY CAVES IN WHICH AVG WEIGHT OF BEARS IS > 200
SELECT B.CAVE_ID, CAVE.CAVE_NAME, AVG(B.WEIGHT) AS AVG_WEIGHT
FROM BEAR B
INNER JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID
GROUP BY B.CAVE_ID, CAVE.CAVE_NAME
HAVING AVG(B.WEIGHT) > 200;

--VIEWS

--HOW MANY BEARS PER CAVE?
CREATE VIEW VW_BEARS_PER_CAVE(CAVE, NUMBEAR)
AS
SELECT CAVE_NAME, COUNT(BEAR_ID) --SYSTEM-DEFINED AGGREGATE FUNCTION (AS OPPOSED A SCALAR FUNCTION)
FROM BEAR, CAVE
WHERE BEAR.CAVE_ID = CAVE.CAVE_ID
GROUP BY CAVE_NAME;

SELECT * FROM VW_BEARS_PER_CAVE;

--USER-DEFINED FUNCTIONS
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER(X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    IF X>Y THEN
    Z := X; --PL/SQL ASSIGNMENT OPERATOR
    ELSE
    Z := Y;
    END IF;
    RETURN Z;
END;

--CALL OUR FUNCTION!
DECLARE
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
    FIRST_NUM := 22;
    SECOND_NUM := 42;
    MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM);
END;

--CURSOR: POINTER TO THE 'ACTIVE SET'
--MOVE THROUGH A RESULT SET AND PROCESS EACH LINE
CREATE OR REPLACE FUNCTION PRINT_ALL_BEARS
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR 
    SELECT BEAR_ID, BEAR_NAME FROM BEAR;
    RETURN S;
END;

--INVOKE THE FUNCTION
DECLARE
S SYS_REFCURSOR;
SOME_ID BEAR.BEAR_ID%TYPE; --DECLARES SOME_ID IS THE SAME DATATYPE AS BEAR.BEAR_ID
SOME_NAME BEAR.BEAR_NAME%TYPE;
BEGIN
    S := PRINT_ALL_BEARS;
    LOOP
    FETCH S INTO SOME_ID, SOME_NAME; --GRAB VALUES IN COLUMNS OF NEXT ROW IN ACTIVE SET
    EXIT WHEN S%NOTFOUND;            --AND ASSIGN THEM TO SOME_ID, SOME_NAME
    DBMS_OUTPUT.PUT_LINE('ID: '||SOME_ID||', NAME: '||SOME_NAME);
    END LOOP;
    CLOSE S;
END;

--NOW, A STORED PROCEDURE
CREATE OR REPLACE PROCEDURE SP_FEED_BEAR(B_ID IN NUMBER, H_ID IN NUMBER, HONEY_AMT IN NUMBER, AMT_FED OUT NUMBER)
IS
BB_EXISTS INTEGER;
BEGIN
    --CHECK THAT THIS BEAR IS CORRECTLY MATCHED TO THIS BEEHIVE
    --IF IT IS, AND HONEY_AMT > 0 
    --REDUCE HIVE WEIGHT
    --INCREASE BEAR WEIGHT
    --SET RETURN AMOUNT
END;
